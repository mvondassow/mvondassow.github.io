<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  <script src="http://www.numericjs.com/lib/numeric-1.2.6.min.js"></script>
</head>
<html>
  <body>
    <p>This is an attempt to visuallize covariant and contravariant components of vectors. If you let your eyes cross until the left and right images overlap, you can see the system in 3D.</p>

    <svg id="v1" width="300" height="300"></svg>
    <svg id="v2" width="300" height="300"></svg>    

<div>
    <button type="button" id="myBtn" onclick="myfun()" style="float:right">Use transformation</button>

    <p>Enter a tranformation: </p>
    <table id="trTab">
    </table>
    
    <p>Enter a vector: </p>
    <table id="vecTab">
    </table>    

    <p id="test">
    </p>
</div>

    <script>
      var B0 = [ [1,0,0], [0,1,0], [0,0,1] ]; // Initial transformation matrix
      /* Initialize variables (DOM input object array, vector group, plot groups
       * angle between image, and variable for loops)
      */
      var trTable, V, f1, f2, theta, item, newVecTable, nCols;

      /*
      * Create a table of input (Numeric) input fields with step defined
      * @param {array} B Initial values for elements in table of input fields
      * @return {array} Array of input DOM element objects
      */
      function addInputTable(B, tabID, props) {
        //Define default values
        var step = ((typeof props === "undefined")||
                (typeof props["step"] === "undefined"))?0.1:props["step"];
        var style = ((typeof props === "undefined")||
                (typeof props["style"] === "undefined"))?"width:7em":props["style"];
        var decimals = ((typeof props === "undefined")||
                (typeof props["decimals"] === "undefined"))?10:props["decimals"];

        // newTable: variable for table; row/col: variables for row and col count
        var newTable, row, col, newcell, corval; 
        var tr=[]; // Initialize array for rows
        var inputs=[]; // Initialize array for input fields
        newTable = document.getElementById(tabID); // Get table element

        for (row=0; row < B.length; row++){
          tr[row] = newTable.insertRow(row); // Add new row to table
          inputs.push([]); // Add new array (row) element to inputs array.

          // Handle case when not array of arrays.
          nCols = (typeof B[row].length === "undefined")?1:B[row].length;

          for (col=0; col < nCols; col++){
            newcell = tr[row].insertCell(col); // Add new table cell
            // Create input element, set type and value, and add to table cell 
            // in DOM
            inputs[row][col]=document.createElement("INPUT");
            inputs[row][col].setAttribute("type", "number");
            // Set value and handle cases when element is single value or array
            curval = (typeof B[row].length === "undefined")?B[row]:B[row][col]
            inputs[row][col].setAttribute("value",
                Math.round(Math.pow(10, decimals)*curval)/Math.pow(10,decimals));
            inputs[row][col].setAttribute("step", step);
            inputs[row][col].setAttribute("style", style);
            newcell.appendChild(inputs[row][col]);
          }
        }

        return inputs;
      }

      /*
      * Read values from an array of DOM input fields.
      * @param {array} inputArray Array of input DOM objects
      * @return {array} Values from input elements in array
      */
      function readInputs(inputArray) {
        var outs = []; // Initialize array to store values from input table.
        var row, col
        for (row=0; row < inputArray.length; row++){
          outs.push([]); // Add new array element (row) to output array.
          for (col=0; col < inputArray[row].length; col++){
            // Get value from each input DOM element
            outs[row][col]=inputArray[row][col].value; 
          }
        }
        return outs;
      }

      /*
      * For space with dim of input array, create a unit vector with random
      * orientation
      * @param {array} nxn array of arrays.
      * @return {array} random vector.
      */
      function rand3Vect() {
        // Generate rotation angles for all three axes (could just do 2, but...)
        var T = [Math.random(), Math.random(), Math.random()].map(
                function (x) {return x*2*Math.PI});
        var sinT = T.map(Math.sin);
        var cosT = T.map(Math.cos);

        var col, row, V;

        // Generate individual rotation matrices.
        var R3 = [ [cosT[2], -sinT[2], 0], [sinT[2], cosT[2], 0], [0, 0, 1] ];
        var R2 = [ [cosT[1], 0, sinT[1]], [0, 1, 0], [-sinT[1], 0, cosT[1]] ];
        var R1 = [ [1, 0, 0], [0, cosT[0], -sinT[0]], [0, sinT[0], cosT[0]] ];

        // Rotate unit vector
        return numeric.dot(numeric.dot(numeric.dot(R3, R2), R1), [1,0,0]);
      }

      /*
      * Find projection of vector vec onto plane defined by p1 & p2 (p1 and p2 
      * are orthogonal unit basis vectors of plane)
      * unit vectors, result is 
      * @param {array} vec Vector (1d array) whose projection is sought 
      * @param {array} p1 Unit vector in plane
      * @param {array} p2 Unit vector in plane orthogonal to p2
      * @return {array} Projection of 'vec' onto plane defined by 'normal'
      */
      function projOnPlane(vec, p1, p2, tol) {
        var tol = (typeof tol !== "undefined")?tol:0.001
        try {
            if(Math.abs(numeric.norm2(p1) - 1) > tol) throw "p1 is not a unit vector";
            if(Math.abs(numeric.norm2(p2) - 1) > tol) throw "p2 is not a unit vector";
            if(Math.abs(numeric.dot(p1, p2)) > tol) throw "p1 and p2 are not orthogonal";
        }
        catch(err) {
            window.alert("projOnPlane: " + err + ". Values may not be as expected");
        } finally {
          return [numeric.dot(vec, p1), numeric.dot(vec, p2)];
        }
      }

      /* Change attributes of a line element to show vec projection on p1-p2
      *  plane.
      * @param {object} li Line element to change
      * @param {array} vec Vector to plot: numeric 1D array with length 3
      * @param {array} p1 Basis vector for plane: numeric 1D array with length 3
      * @param {array} p2 Basis vector for plane: numeric 1D array with length 3
      * @param {array} xy0 Two element array: x-y coordinates of origin.
      * @param {number} scale Scaling for vector
      * @param {string} style String to give vector styling
      */
      function plotVec(li, vec, p1, p2, xy0, scale, style) {
        var xy = projOnPlane(vec, p1, p2);
        // Check whether called with style parameter; otherwise use defaults
        var style = (typeof style !== "undefined") ? style : "stroke:rgb(0,0,0);stroke-width:2"
        li.setAttribute("x1", xy0[0]);
        li.setAttribute("y1", xy0[1]);
        li.setAttribute("x2", scale*xy[0]+xy0[0]);
        // Makes Y negative because y axis points downward in SVG.
        li.setAttribute("y2", -scale*xy[1]+xy0[1]); 
        // Add line styling
        li.setAttribute("style", style);
      }
      
      /* Create onject with elements associated with svg system
       * @param {string} svgID ID of svg element in HTML
       * @property {object} svg SVG DOM object
       * @property {array} xy0 2 element array with x-y center numbers
       * @property {numeric} scale Scale factor for line display
       * @property {object} lines Line elements associated with plotGroup object
       * @ 
      */

      function plotGroup(svgID) {
        //for getting x-y center
        this.svg = document.getElementById(svgID);
        this.xy0 = [ this.svg.attributes.getNamedItem("width").value/2,
                    this.svg.attributes.getNamedItem("height").value/2  ];
        this.scale = 0.75*Math.min(this.xy0[0], this.xy0[1])
        this.lines = {};
        /*
        * Add line element to svg and associate with 'this.lines' property
        * @param {string} vecName Name of vector associated with line
        */
        this.newLine = function(vecName) {
          var li = document.createElementNS('http://www.w3.org/2000/svg','line');
          this.svg.appendChild(li);
          this.lines[vecName] = li;
        };

      }

      /* Generate vectors.
       * @param {array} B Array (2d) representing transformation from rectilinear
            cartesian coordinate system
       * @property {object} this.V Random vector with coordinates in V.xyz, 
            drawing style in V.style
       * @property {object} this.B* Contravariant basis vectors (specified as for V)
       * @property {object} this.b* Covariant basis vectors (specified as for V)
      */
      function vectorGroup (B) {
        var BT = numeric.transpose(B);
        var bTt = numeric.inv(B);

        // Create random vector
        this.V = {xyz: rand3Vect(), 
                         style: "stroke:rgb(255,0,0);stroke-width:2"};

        // Create vectors for contravariant basis
        this.B0 = {xyz: BT[0], style: "stroke:rgb(0,120,0);stroke-width:2"};
        this.B1 = {xyz: BT[1], style: "stroke:rgb(0,180,0);stroke-width:2"};
        this.B2 = {xyz: BT[2], style: "stroke:rgb(0,240,0);stroke-width:2"};

        // Create vectors for covariant basis
        this.b0 = {xyz: bTt[0], style: "stroke:rgb(0,0,120);stroke-width:2"};
        this.b1 = {xyz: bTt[1], style: "stroke:rgb(0,0,180);stroke-width:2"};
        this.b2 = {xyz: bTt[2], style: "stroke:rgb(0,0,240);stroke-width:2"};
      }



      
    try { 
      // Create table for user input.
      trTable = addInputTable(B0, 'trTab');
      // Create plotting elements
      theta = 2;
      f1 = new plotGroup("v1");
      f1.p1 = [Math.cos(Math.PI*theta/180),0, Math.sin(Math.PI*theta/180)]
      f1.p2 = [0,1,0]
      f2 = new plotGroup("v2");
      f2.p1 = [Math.cos(-Math.PI*theta/180),0, Math.sin(-Math.PI*theta/180)]
      f2.p2 = [0,1,0]
      // Create set of vectors
      V = new vectorGroup(readInputs(trTable));

      // Create table to enter vector
      newVecTable = addInputTable(V.V.xyz, 'vecTab');

      // Plot vectors
      for (item in V) {
        f1.newLine(item); 
        f2.newLine(item);
        plotVec(f1.lines[item], V[item].xyz, f1.p1, f1.p2, f1.xy0, 
            f1.scale, V[item].style);
        plotVec(f2.lines[item], V[item].xyz, f2.p1, f2.p2, f2.xy0,
            f2.scale, V[item].style);
      }
    } catch(err) {
      window.alert("A: " + err);
    }


      // Function to confirm input and transformed vector.
      function myfun () {
try {
        var T = readInputs(trTable);
        var tt = numeric.transpose(numeric.inv(T));
        // readInputs() returns array of arrays so have to flatten.
        var xyz = readInputs(newVecTable);
        V.V.xyz = [xyz[0][0], xyz[1][0], xyz[2][0]];

        V.b0.xyz = numeric.dot(tt, V.b0.xyz);
        V.b1.xyz = numeric.dot(tt, V.b1.xyz);
        V.b2.xyz = numeric.dot(tt, V.b2.xyz);

        V.B0.xyz = numeric.dot(T, V.B0.xyz);
        V.B1.xyz = numeric.dot(T, V.B1.xyz);
        V.B2.xyz = numeric.dot(T, V.B2.xyz);
        
        for (item in V) {
            plotVec(f1.lines[item], V[item].xyz, f1.p1, f1.p2, 
                f1.xy0, f1.scale, V[item].style);
            plotVec(f2.lines[item], V[item].xyz, f2.p1, f2.p2, 
                f2.xy0, f2.scale, V[item].style);
        }


        document.getElementById("test").innerHTML = 
            "det(Transform): " + numeric.det(T) + 
            "<br> det(inv.transform): " + numeric.det(tt) + 
            "<br> det(B): " + numeric.det([V.B0.xyz,V.B1.xyz,V.B2.xyz]) + 
            "<br> det(b): " + numeric.det([V.b0.xyz,V.b1.xyz,V.b2.xyz]) + 
            "<br> T: " + JSON.stringify(T) + 
            "<br> V: " + xyz;
} catch(err) {
  window.alert("B: " + err);
}
      }

/* 
* 1) Put plotting function as method for vectors group with plotGroup as parameter
* 2) Put transformation as method for vector group with matrix as parameter
    -- Check transformations carefully
* 3) Add method for user specification of vector to vector group
*/

    </script>
  </body>
</html>
